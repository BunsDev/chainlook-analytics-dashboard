import { Link } from 'react-router-dom';

function DocsPage() {
  return (
    <div className='page docs-page'>
      <div className='docs-section'>
        <p>
          ChainLook is an analytics platform for visualizing blockchain data from decentralized data
          source like{' '}
          <a href='https://thegraph.com/' rel='noreferrer' target='_blank'>
            The Graph
          </a>
          .
        </p>
        <p>This is a small guide to help you build widgets and dashboards using ChainLook.</p>
      </div>

      <hr />

      <div className='docs-section'>
        <div className='docs-section-title'>Widget Wizard</div>
        <p>
          The easiest way to get started is by creating a widget using the Widget Wizard. Navigate
          to <Link to='/widgets/new'>New Widget</Link> page and click on the <b>Use Wizard</b>{' '}
          button.
        </p>
        <img src='/assets/wizard.png' width={800} alt='Widget Wizard' />
        <p>In the popup, you can start by setting the ID of the subgraph.</p>

        <blockquote>
          <p>
            ChainLook support subgraphs deployed to both the hosted service and decentralized
            network (using Subgraph Studio). The ID of the subgraph to use would depend on where
            your subgraph is deployed.
          </p>
          <p>
            Use <code>@username/subgraph-name</code> format for hosted service. Eg:{' '}
            <code>airswap/airswap</code>, <code>ensdomains/ens</code>
            <br />
            Use the subgraph ID as seen in the Graph Explorer for the decentralized network. Eg:{' '}
            <code>9MDH6TTFm2KZWbo1dBhyktQ7WkWWAbVRSF6Eg65mu9z9</code>
          </p>
        </blockquote>

        <p>
          You need to have a fair understanding of the subgraph you are going to visualize - mainly
          its entities, queries and fields.
        </p>

        <p>Once you set the subgraph ID, rest of the configuration field will become active.</p>

        <p>
          In the first section you can set the <b>Query, Order By and Order Direction</b>. These
          would be used to build the GraphQL query used to fetch data from the subgraph.
        </p>

        <p>
          In the bottom part, you can select the type of widget you want to build from the query
          result. Depending on the widget selected, additional configuration fields will be
          displayed.
        </p>

        <ul>
          <li>
            If you choose Table, you would be able to set which fields from the result need to be
            shown as <b>columns</b>.
          </li>
          <li>
            For Charts, you can set field to be used for X-axis, and the fields to be used for
            lines, bars and areas. You can also build a combination of{' '}
            <b>line-chart, bar-chart and area-chart</b> in the same widget.
          </li>
          <li>
            Similarly, you can set the fields to be displayed for other widgets like Pie Chart,
            Metric, etc.
          </li>
        </ul>

        <p>
          Once you are done, click on the <b>Submit</b> button to generate the widget definition.
          You would be able to see a preview of the widget. If you are happy with the results, you
          can then publish the widget and share it with others.
        </p>
      </div>

      <hr />

      <div className='docs-section'>
        <div className='docs-section-title'>Widget Definition Editor</div>
        <p>
          You can also create a widget by manually writing the definition, or by editing the JSON
          generated by the widget wizard.
        </p>
        <p>
          The editor is intelligent and will suggest values for many fields as soon as you set the
          subgraphId key.
        </p>
        Widget definition should have the below three keys at the root level:
        <ul>
          <li>
            <code>type</code> : Type of the widget - chart, table, metric, pieChart.
          </li>
          <li>
            <code>data</code> : Data source configuration.
          </li>
          <li>
            <code>table | chart | metric | pieChart</code> : Used to configure how the widget should
            be rendered. Key should be same as the value used for 'type'.
          </li>
        </ul>
        <code className='code-block'>
          {`{
  "type": "table",
  "data": {
    "source": {
      "provider": "graph",
      "subgraphId": "messari/uniswap-v3-ethereum",  // subgraph ID
      "query": "financialsDailySnapshots",          // name of the query
      "orderBy": "timestamp",
      "orderDirection": "desc"
      "where": {}                 // added as 'where' parameter in the query
    }
  },
  "table": {},

  /**
  "chart": {},
  "pieChart": {},
  "metric": {},
  */
}
`}
        </code>
        <div className='docs-section-subtitle'>Table</div>
        <code className='code-block'>
          {`{
  ...
  "table": {
    "columns": [           // list of columns to be shown in the table
      {
        "dataKey": "timestamp",     // name of the field in the query result
        "format": "localeDate",     // format the value - list of formatters below
        "label": "Date"             // label to be shown in the table header
      },
      {
        "dataKey": "dailyVolumeUSD",
        "format": "number"
      }
    ]
  }
}
`}
        </code>
        <div className='docs-section-subtitle'>Chart</div>
        <code className='code-block'>
          {`{
  ...
  "chart": {
    "xAxis": {
      "dataKey": "timestamp",   // field to be rendered on X-axis
      "format": "dateMMMdd",
      "reversed": true          // reverse the order of the data
    },
    "yAxis": {
      "format": "number"        // format the value on Y-axis
    },
    "lines": [                  // list of lines to be shown in the chart
      {
        "dataKey": "dailyActiveUsers",    // field to be used for line
        "label": "Daily Active Users"
      }
    ],
    "bars": [                             // list of bars to be shown in the chart
      {
        "dataKey": "dailySwapCount",
        "label": "Daily Swap Count"
      }
    ],
    "areas": []                           // list of areas to be shown in the chart
  }
}
`}
        </code>
        <div className='docs-section-subtitle'>PieChart</div>
        <code className='code-block'>
          {`{
  ...
  "pieChart": {
    "dataKey": "totalValueLockedUSD",   // Field for creating the pies
    "nameKey": "pool.name",             // Field to be used as the label
    "format": "currency"
  }
}
`}
        </code>
        <div className='docs-section-subtitle'>Metric</div>
        <p>
          Metric is a simple widget that display a single value in a big size. This can be used to
          show key metrics (of protocols) at the top of a dashboard.
        </p>
        <code className='code-block'>
          {`{
  ...
  "metric": {
    "dataKey": "totalPoolCount",
    "format": "number"
  }
}
`}
        </code>
        <hr />
        <div className='docs-section-subtitle'>Multiple Data Source</div>
        <p>
          You can create a widget that uses data from multiple subgraphs. You can join the data
          using same fields in both source, similar to SQL join statement.
        </p>
        <code className='code-block'>
          {`{
  "data": {
    "sources": {              // Use sources instead of source
      "ethereum": {           // Add a key for each source
        "provider": "graph",
        "subgraphId": "messari/uniswap-v3-ethereum",
        "query": "financialsDailySnapshots"
      },
      "polygon": {
        "provider": "graph",
        "subgraphId": "messari/uniswap-v3-polygon",
        "query": "financialsDailySnapshots"
      }
    },
    "join": {
      "polygon.timestamp": "ethereum.timestamp"    // Join the data using same field in both source
    }
  },
  "type": "chart",
  "chart": {
    "xAxis": {
      "dataKey": "ethereum.timestamp"               // Prefix the field name with source key
    },
    "lines": [
      {
        "dataKey": "ethereum.totalValueLockedUSD"   // Prefix the field name with source key
      },
      {
        "dataKey": "polygon.totalValueLockedUSD"
      }
    ]
  }
}
`}
        </code>
        <hr />
        <div className='docs-section-subtitle'>Transforms</div>
        <p>
          You can transform data received from the subgraph before it is used to render in the
          widget.
        </p>
        <code className='code-block'>
          {`{
  ...
  "data": {
    ...
    "transforms": {
      "polygon.timestamp": "startOfDay"       // fieldName: transformName
    }
  }
}
`}
        </code>
        Below is the list of available transform functions:
        <ul>
          <li>
            <code>startOfDay</code> : Convert the timestamp to start of the day.
          </li>
          <li>
            <code>endOfDay</code> : Convert the timestamp to end of the day.
          </li>
          <li>
            <code>startOfWeek</code> : Convert the timestamp to start of the week.
          </li>
          <li>
            <code>endOfWeek</code> : Convert the timestamp to end of the week.
          </li>
          <li>
            <code>startOfMonth</code> : Convert the timestamp to start of the month.
          </li>
          <li>
            <code>endOfMonth</code> : Convert the timestamp to end of the month.
          </li>
          <li>
            <code>startOfYear</code> : Convert the timestamp to start of the year.
          </li>
          <li>
            <code>endOfYear</code> : Convert the timestamp to end of the year.
          </li>
        </ul>
        <hr />
        <div className='docs-section-subtitle'>Grouping</div>
        <p>
          You can group the query result by a field before it is used to render in the widget. It
          works similar to SQL group by statement where you specify a group key and aggregation for
          each to be applied to multiple items in the group.
        </p>
        <code className='code-block'>
          {`{
  ...
  "data": {
    ...
    "group": {
      "key": "pool.symbol",       // field to be used as the group key
      "aggregations": {
        "dailyTotalVolumeUSD": "sum"  // field: aggregationFunction
      }
    }
  }
}
`}
        </code>
        Below is the list of available aggregation functions:
        <ul>
          <li>
            <code>sum</code> : Sum of all the values in the group.
          </li>
          <li>
            <code>multiply</code> : Multiply all the values in the group.
          </li>
          <li>
            <code>avg</code> : Average of all the values in the group.
          </li>
          <li>
            <code>min</code> : Minimum of all the values in the group.
          </li>
          <li>
            <code>max</code> : Maximum of all the values in the group.
          </li>
          <li>
            <code>first</code> : First item in the group.
          </li>
          <li>
            <code>last</code> : Last item in the group.
          </li>
          <li>
            <code>count</code> : Count of all the items in the group.
          </li>
        </ul>
        <p>
          By default, the aggregation is <code>first</code> (assuming the value is same for all
          items in the group).
        </p>
        <hr />
        <div className='docs-section-subtitle'>Dynamic Fields</div>
        <p>You can create a new fields in the result by using the existing fields.</p>
        <code className='code-block'>
          {`{
  ...
  "data": {
    ...
    "dynamicFields": {
      "totalTVL": {                         // key of the field to be created
        "operation": "sum",                 // operation to be applied to the fields
        "fields": [                         // list of fields to be used in the calculation
          "ethereum.totalValueLockedUSD",
          "polygon.totalValueLockedUSD",
        ]
      }
    }
  }
}
`}
        </code>
        You can use the dynamic field in the widget ('dataKey') just like any other field.
        <div className='docs-section-important'>
          The order in which above data modifiers are applies is as follows:
          <ul>
            <li>Apply transforms.</li>
            <li>Join results from multiple sources.</li>
            <li>Apply grouping.</li>
            <li>Compute dynamic fields.</li>
          </ul>
          This means you can apply transformation to the data and use the transform field for joins
          and grouping.
        </div>
        <hr />
        <div className='docs-section-subtitle'>Formatters</div>
        <p>
          Formatters don't modify the original data and only format the value render in the widget -
          meaning the raw data would be used for groups, joins and dynamic fields.
          <br />
          Below is the list of available formatters that can be used to format data displayed in the
          chart.
        </p>
        <ul>
          <li>
            <code>localeDate</code> : Format the date in user's local format.
          </li>
          <li>
            <code>localeDateTime</code> : Format the date and time in user's local format.
          </li>
          <li>
            <code>dateMMMdd</code> : Format the date in MMM dd format. Eg: Jan 01
          </li>
          <li>
            <code>dateYYYYmmdd</code> : Format the date in YYYY-MM-DD format. Eg: 2021-01-01
          </li>
          <li>
            <code>roundedNumber</code> : Format the number to 2 decimal places.
          </li>
          <li>
            <code>number</code> : Format as number. Eg: 1000000 -&gt; 1,000,000
          </li>
          <li>
            <code>currency</code> : Format the number as currency. Eg: 1000000 -&gt; 1,000,000
          </li>
          <li>
            <code>currencyUSD</code> : Add $ sign to the number.
          </li>
          <li>
            <code>compactNumber</code> : Format the number in compact format. Eg: 1000000 -&gt; 1M
          </li>
          <li>
            <code>bigDecimal</code> : Format bigDecimal type returned from subgraphs.
          </li>
          <li>
            <code>bigDecimalCompact</code>
          </li>
          <li>
            <code>camelCaseToTitle</code> : Convert camel case string to title case.
          </li>
        </ul>
        <hr />
        <div className='docs-section'>
          <div className='docs-section-title'>A complex example</div>
          <p>
            Below is an example of a complex definition that uses almost all the above data
            modifiers. The widget display TVL of uniswap from all networks as a line chart.
          </p>
          <code className='code-block'>
            {`{
  "data": {
    "sources": {                                      // three different sources
      "ethereum": {
        "provider": "graph",
        "subgraphId": "messari/uniswap-v3-ethereum",  // subgraph id
        "query": "financialsDailySnapshots",          // query name - this query has daily TVL data
        "orderBy": "timestamp",                       // order by timestamp descending
        "orderDirection": "desc",
        "first": 30                                   // last 30 days (first 30 items in desc order)
      },
      "polygon": {
        "provider": "graph",
        "subgraphId": "messari/uniswap-v3-polygon",
        "query": "financialsDailySnapshots",
        "orderBy": "timestamp",
        "orderDirection": "desc",
        "first": 30
      },
      "arbitrum": {
        "provider": "graph",
        "subgraphId": "messari/uniswap-v3-arbitrum",
        "query": "financialsDailySnapshots",
        "orderBy": "timestamp",
        "orderDirection": "desc",
        "first": 30
      }
    },
    "transforms": {
      "polygon.timestamp": "startOfDay",            // transform timestamp to start of day
      "ethereum.timestamp": "startOfDay",
      "arbitrum.timestamp": "startOfDay"
    },
    "join": {
      "ethereum.timestamp": "arbitrum.timestamp",   // join all source based on transformed timestamp
      "polygon.timestamp": "ethereum.timestamp"
    },
    "group": {
                                                    // we may group by timestamp if there is 
                                                    // multiple entry for same date, and sum the TVL
    },
    "dynamicFields": {
      "totalTVL": {                                 // create a new field that is sum of all TVL
        "fields": [
          "ethereum.totalValueLockedUSD",
          "polygon.totalValueLockedUSD",
          "arbitrum.totalValueLockedUSD"
        ],
        "operation": "sum"
      }
    }
  },
  "type": "chart",
  "chart": {
    "xAxis": {
      "dataKey": "ethereum.timestamp",                // use timestamp from either source (joined)
      "format": "localeDate",                         // format the date in user's local format
      "reversed": true                                // reverse the order so latest data is on left
    },
    "lines": [                                        // add lines for each network
      {
        "dataKey": "ethereum.totalValueLockedUSD",
        "label": "Ethereum"
      },
      {
        "dataKey": "polygon.totalValueLockedUSD",
        "label": "Polygon"
      },
      {
        "dataKey": "arbitrum.totalValueLockedUSD",
        "label": "Arbitrum"
      },
      {
        "dataKey": "totalTVL",
        "label": "Total"
      }
    ],
    "yAxis": {
      "format": "currencyUSD"                       // format the y axis as currency (TVL)
    }
  }
}
`}
          </code>

          <p>
            You can see any other examples in the New Widget page, by clicking on the "Load Example"
            button in the definition editor.
          </p>
        </div>
        <hr />
        <p>
          Once you have created multiple widgets, head over to the{' '}
          <Link to='/dashboards/new'>New Dashboard</Link> page to create a dashboard from your
          widgets. Dashboard editor is very simple, where you can drag and drop widgets, order them,
          resize them, etc.
        </p>
      </div>
    </div>
  );
}

export default DocsPage;
